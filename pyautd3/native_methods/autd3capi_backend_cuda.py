# This file is autogenerated
import threading
import ctypes
import os
from pyautd3.native_methods.structs import Vector3, Quaternion, FfiFuture, LocalFfiFuture, SamplingConfig
from pyautd3.native_methods.autd3capi_driver import GainPtr

from pyautd3.native_methods.autd3capi_gain_holo import BackendPtr, EmissionConstraintWrap, ResultBackend



class Singleton(type):
    _instances = {}  # type: ignore
    _lock = threading.Lock()

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances: # pragma: no cover
                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class NativeMethods(metaclass=Singleton):

    def init_dll(self, bin_location: str, bin_prefix: str, bin_ext: str):
        try:
            self.dll = ctypes.CDLL(os.path.join(bin_location, f'{bin_prefix}autd3capi_backend_cuda{bin_ext}'))
        except Exception:   # pragma: no cover
            return          # pragma: no cover

        self.dll.AUTDCUDABackend.argtypes = [] 
        self.dll.AUTDCUDABackend.restype = ResultBackend

        self.dll.AUTDCUDABackendDelete.argtypes = [BackendPtr]  # type: ignore 
        self.dll.AUTDCUDABackendDelete.restype = None

        self.dll.AUTDGainHoloCUDAGS.argtypes = [BackendPtr, ctypes.POINTER(Vector3), ctypes.POINTER(ctypes.c_float), ctypes.c_uint32, ctypes.c_uint32, EmissionConstraintWrap]  # type: ignore 
        self.dll.AUTDGainHoloCUDAGS.restype = GainPtr

        self.dll.AUTDGainHoloCUDAGSPAT.argtypes = [BackendPtr, ctypes.POINTER(Vector3), ctypes.POINTER(ctypes.c_float), ctypes.c_uint32, ctypes.c_uint32, EmissionConstraintWrap]  # type: ignore 
        self.dll.AUTDGainHoloCUDAGSPAT.restype = GainPtr

        self.dll.AUTDGainHoloCUDANaive.argtypes = [BackendPtr, ctypes.POINTER(Vector3), ctypes.POINTER(ctypes.c_float), ctypes.c_uint32, EmissionConstraintWrap]  # type: ignore 
        self.dll.AUTDGainHoloCUDANaive.restype = GainPtr

        self.dll.AUTDGainHoloCUDALM.argtypes = [BackendPtr, ctypes.POINTER(Vector3), ctypes.POINTER(ctypes.c_float), ctypes.c_uint32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_uint32, EmissionConstraintWrap, ctypes.POINTER(ctypes.c_float), ctypes.c_uint64]  # type: ignore 
        self.dll.AUTDGainHoloCUDALM.restype = GainPtr

    def cuda_backend(self) -> ResultBackend:
        return self.dll.AUTDCUDABackend()

    def cuda_backend_delete(self, backend: BackendPtr) -> None:
        return self.dll.AUTDCUDABackendDelete(backend)

    def gain_holo_cudags(self, backend: BackendPtr, points: ctypes.Array | None, amps: ctypes.Array[ctypes.c_float] | None, size: int, repeat: int, constraint: EmissionConstraintWrap) -> GainPtr:
        return self.dll.AUTDGainHoloCUDAGS(backend, points, amps, size, repeat, constraint)

    def gain_holo_cudagspat(self, backend: BackendPtr, points: ctypes.Array | None, amps: ctypes.Array[ctypes.c_float] | None, size: int, repeat: int, constraint: EmissionConstraintWrap) -> GainPtr:
        return self.dll.AUTDGainHoloCUDAGSPAT(backend, points, amps, size, repeat, constraint)

    def gain_holo_cuda_naive(self, backend: BackendPtr, points: ctypes.Array | None, amps: ctypes.Array[ctypes.c_float] | None, size: int, constraint: EmissionConstraintWrap) -> GainPtr:
        return self.dll.AUTDGainHoloCUDANaive(backend, points, amps, size, constraint)

    def gain_holo_cudalm(self, backend: BackendPtr, points: ctypes.Array | None, amps: ctypes.Array[ctypes.c_float] | None, size: int, eps_1: float, eps_2: float, tau: float, k_max: int, constraint: EmissionConstraintWrap, initial_ptr: ctypes.Array[ctypes.c_float] | None, initial_len: int) -> GainPtr:
        return self.dll.AUTDGainHoloCUDALM(backend, points, amps, size, eps_1, eps_2, tau, k_max, constraint, initial_ptr, initial_len)
